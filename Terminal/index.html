<!DOCTYPE html>
<html>

<head>
  <script src="https://unpkg.com/xterm@4.19.0/lib/xterm.js"></script>
  <script src="Javascript/xterm.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/xterm@4.18.0/css/xterm.css" />
  <link rel="stylesheet" href="css/modern.css">

  <script>
    "use strict";

    /**
     * Altair Terminal Web Client
     * Improved version with better error handling, code organization, and robustness
     */
    const AltairTerminal = (function() {
      // Private state - encapsulated to avoid global pollution
      const state = {
        ws: null,
        connected: false,
        online: navigator.onLine,
        characterMode: false,
        currentLine: "",
        term: null,
        reconnectAttempts: 0,
        maxReconnectAttempts: 5,
        reconnectDelay: 2000,
        pasteHandler: null,
        keyHandler: null,
        cleanupInterval: null
      };

      // Configuration constants
      const CONFIG = {
        XTERM_FONT: 'Courier',
        XTERM_FONT_SIZE: 18,
        XTERM_ROWS: 28,
        XTERM_COLS: 104,
        WEBSOCKET_PORT: 8082,
        MAX_PASTE_LENGTH: 256,
        STORAGE_THEME_KEY: 'altair_theme',
        DEFAULT_THEME: 'dark',
        MAX_SCROLLBACK_LINES: 1000,
        BUFFER_CLEANUP_INTERVAL: 300000, // 5 minutes
        MAX_CURRENT_LINE_LENGTH: 10000
      };

      // DOM element cache
      const elements = {
        terminal: null,
        hostName: null,
        inputMode: null,
        toggleTheme: null
      };

      /**
       * Initialize DOM element references with error checking
       */
      function initializeElements() {
        try {
          elements.terminal = document.getElementById("terminal");
          elements.hostName = document.getElementById("host_name");
          elements.inputMode = document.getElementById("inputmode");
          elements.toggleTheme = document.getElementById("toggleTheme");

          // Validate critical elements exist
          if (!elements.terminal) {
            throw new Error("Terminal container element not found");
          }
        } catch (error) {
          console.error("Failed to initialize DOM elements:", error);
          showError("Failed to initialize terminal interface");
          return false;
        }
        return true;
      }

      /**
       * Safe error display without using alert()
       */
      function showError(message) {
        console.error("Altair Terminal Error:", message);
        if (elements.hostName) {
          elements.hostName.textContent = `Error: ${message}`;
          elements.hostName.style.color = 'red';
        }
      }

      /**
       * Safe message display
       */
      function showMessage(message, isError = false) {
        console.log("Altair Terminal:", message);
        if (elements.hostName) {
          elements.hostName.textContent = message;
          elements.hostName.style.color = isError ? 'red' : '';
        }
      }

      /**
       * Network status management
       */
      function initializeNetworkHandlers() {
        window.addEventListener('offline', () => {
          console.log('Connection lost');
          state.online = false;
          showMessage('Connection lost', true);
        });

        window.addEventListener('online', () => {
          console.log('Connection restored');
          state.online = true;
          showMessage('Connection restored');
          // Attempt to reconnect if we were previously connected
          if (state.connected && (!state.ws || state.ws.readyState !== WebSocket.OPEN)) {
            setTimeout(() => attemptConnection(), 1000);
          }
        });
      }

      /**
       * Initialize xterm.js terminal with error handling
       */
      function initializeTerminal() {
        try {
          // Check if Terminal is available
          if (typeof Terminal === 'undefined') {
            throw new Error("xterm.js library not loaded");
          }

          state.term = new Terminal({
            cursorBlink: "block",
            fontFamily: CONFIG.XTERM_FONT,
            fontSize: CONFIG.XTERM_FONT_SIZE,
            rows: CONFIG.XTERM_ROWS,
            cols: CONFIG.XTERM_COLS
          });

          if (!elements.terminal) {
            throw new Error("Terminal container not found");
          }

          state.term.open(elements.terminal);
          setTheme();
          state.term.write('WELCOME TO ALTAIR TERMINAL');

          // Set up terminal prompt function
          state.term.prompt = (msg) => {
            if (state.connected && state.online && state.ws) {
              try {
                state.ws.send(msg);
              } catch (error) {
                console.error("Failed to send message:", error);
                showError("Failed to send data to server");
              }
            }
          };

          state.term.prompt("");
          setupTerminalEventHandlers();
          
          return true;
        } catch (error) {
          console.error("Failed to initialize terminal:", error);
          showError("Failed to initialize terminal: " + error.message);
          return false;
        }
      }

      /**
       * Set up terminal event handlers with better error handling
       */
      function setupTerminalEventHandlers() {
        if (!state.term) return;

        // Remove existing handlers first to prevent accumulation
        cleanupTerminalEventHandlers();

        // Store handler references for cleanup
        state.pasteHandler = (data) => {
          if (state.characterMode) return;

          if (typeof data === 'string' && data.length < CONFIG.MAX_PASTE_LENGTH) {
            state.currentLine += data;
            
            // Prevent memory leaks from accumulated paste data
            if (state.currentLine.length > CONFIG.MAX_CURRENT_LINE_LENGTH) {
              console.warn("Current line too long after paste, truncating");
              state.currentLine = state.currentLine.slice(-CONFIG.MAX_CURRENT_LINE_LENGTH / 2);
            }
            
            state.term.write(data);
          } else {
            console.warn("Paste data too long or invalid, ignoring");
          }
        };

        state.keyHandler = (key, ev) => {
          try {
            handleKeyPress(key, ev);
          } catch (error) {
            console.error("Error handling key press:", error);
          }
        };

        // Attach handlers
        state.term.on("paste", state.pasteHandler);
        state.term.on("key", state.keyHandler);
      }

      /**
       * Clean up terminal event handlers
       */
      function cleanupTerminalEventHandlers() {
        if (state.term && state.pasteHandler) {
          try {
            state.term.off("paste", state.pasteHandler);
          } catch (error) {
            console.error("Error removing paste handler:", error);
          }
        }
        if (state.term && state.keyHandler) {
          try {
            state.term.off("key", state.keyHandler);
          } catch (error) {
            console.error("Error removing key handler:", error);
          }
        }
        state.pasteHandler = null;
        state.keyHandler = null;
      }

      /**
       * Handle key press events with better organization
       */
      function handleKeyPress(key, ev) {
        // Handle Ctrl key combinations
        if (ev.ctrlKey) {
          if (ev.keyCode === 76) { // Ctrl+L toggle
            toggleInputMode();
            return;
          }
          sendControlCharacter(String.fromCharCode(ev.keyCode));
          return;
        }

        // Handle Escape key
        if (ev.keyCode === 27) {
          state.term.prompt(key);
          state.term.write(key);
          return;
        }

        if (state.characterMode) {
          handleCharacterMode(key, ev);
        } else {
          handleLineMode(key, ev);
        }
      }

      /**
       * Handle character input mode
       */
      function handleCharacterMode(key, ev) {
        const keyMappings = {
          39: String.fromCharCode(68), // cursor right -> ctrl d
          37: String.fromCharCode(83), // cursor left -> ctrl s
          38: String.fromCharCode(69), // cursor up -> ctrl e
          40: String.fromCharCode(88), // cursor down -> ctrl x
          45: String.fromCharCode(79), // insert -> ctrl o
          46: String.fromCharCode(71), // delete -> ctrl g
          8: String.fromCharCode(72)   // backspace -> ctrl h
        };

        if (keyMappings[ev.keyCode]) {
          sendControlCharacter(keyMappings[ev.keyCode]);
          return;
        }

        if (ev.keyCode === 13) { // Enter
          state.term.prompt("\r");
          state.currentLine = "";
          return;
        }

        // Default character input
        state.currentLine += key;
        
        // Prevent memory leaks from very long lines
        if (state.currentLine.length > CONFIG.MAX_CURRENT_LINE_LENGTH) {
          console.warn("Current line too long, truncating");
          state.currentLine = state.currentLine.slice(-CONFIG.MAX_CURRENT_LINE_LENGTH / 2);
        }
        
        state.term.prompt(key);
        state.term.write(key);
      }

      /**
       * Handle line input mode
       */
      function handleLineMode(key, ev) {
        switch (ev.keyCode) {
          case 39: // cursor right
          case 37: // cursor left  
          case 38: // cursor up
          case 40: // cursor down
            break; // Ignore cursor keys in line mode
          case 13: // Enter
            state.currentLine += "\r";
            state.term.prompt(state.currentLine);
            state.term.write("\r");
            state.currentLine = "";
            break;
          case 8: // Backspace
            if (state.currentLine) {
              state.currentLine = state.currentLine.slice(0, -1);
              state.term.write("\b \b");
            }
            break;
          default:
            state.currentLine += key;
            
            // Prevent memory leaks from very long lines
            if (state.currentLine.length > CONFIG.MAX_CURRENT_LINE_LENGTH) {
              console.warn("Current line too long, truncating");
              state.currentLine = state.currentLine.slice(-CONFIG.MAX_CURRENT_LINE_LENGTH / 2);
            }
            
            state.term.write(key);
        }
      }

      /**
       * Toggle between line and character input modes
       */
      function toggleInputMode() {
        state.characterMode = !state.characterMode;
        const message = state.characterMode 
          ? "Character input mode : Wordmaster (Ctrl+L to toggle)"
          : "Line input mode: Default (Ctrl+L to toggle)";
        
        if (elements.inputMode) {
          elements.inputMode.textContent = message;
        }
      }

      /**
       * Send control character with error handling
       */
      function sendControlCharacter(msg) {
        if (!state.connected || !state.online || !state.ws) return;

        try {
          let output;
          if (msg === 'M') {
            output = String.fromCharCode(28);
          } else {
            const ascii = msg.charCodeAt(0);
            output = String.fromCharCode(ascii & 31);
          }
          state.ws.send(output);
        } catch (error) {
          console.error("Failed to send control character:", error);
          showError("Communication error with server");
        }
      }

      /**
       * Get WebSocket URL with validation
       */
      function getWebSocketUrl() {
        try {
          const urlParams = new URLSearchParams(window.location.search);
          const hostAddress = urlParams.get('altair');
          
          // Validate and sanitize host address
          const altairAddress = hostAddress 
            ? sanitizeHostAddress(hostAddress)
            : window.location.hostname || 'localhost';

          return `ws://${altairAddress}:${CONFIG.WEBSOCKET_PORT}`;
        } catch (error) {
          console.error("Failed to construct WebSocket URL:", error);
          return `ws://localhost:${CONFIG.WEBSOCKET_PORT}`;
        }
      }

      /**
       * Basic host address sanitization
       */
      function sanitizeHostAddress(address) {
        // Remove any protocol prefixes and validate basic format
        const cleaned = address.replace(/^https?:\/\//, '').split('/')[0];
        // Basic validation - allow alphanumeric, dots, hyphens
        if (!/^[a-zA-Z0-9.-]+$/.test(cleaned)) {
          console.warn("Invalid host address, using default");
          return 'localhost';
        }
        return cleaned;
      }

      /**
       * Attempt WebSocket connection with retry logic
       */
      function attemptConnection() {
        if (state.connected) {
          closeConnection();
        }

        const wsUrl = getWebSocketUrl();
        const altairAddress = wsUrl.split('://')[1].split(':')[0];
        
        showMessage(`Connecting to ${altairAddress}...`);

        try {
          state.ws = new WebSocket(wsUrl);
          setupWebSocketEventHandlers(altairAddress);
        } catch (error) {
          console.error("Failed to create WebSocket:", error);
          showError("Failed to create connection");
          scheduleReconnect();
        }
      }

      /**
       * Set up WebSocket event handlers
       */
      function setupWebSocketEventHandlers(altairAddress) {
        if (!state.ws) return;

        state.ws.onopen = () => {
          console.log("WebSocket connected");
          state.connected = true;
          state.reconnectAttempts = 0;
          showMessage(altairAddress);
          if (state.term) {
            state.term.focus();
          }
        };

        state.ws.onmessage = (event) => {
          if (state.term && event.data) {
            try {
              state.term.write(event.data);
            } catch (error) {
              console.error("Error writing to terminal:", error);
            }
          }
        };

        state.ws.onclose = (event) => {
          console.log("WebSocket closed:", event.code, event.reason);
          state.connected = false;
          state.ws = null;
          showMessage('Connection closed. Refresh to reconnect', true);
        };

        state.ws.onerror = (error) => {
          console.error("WebSocket error:", error);
          state.connected = false;
          showError("Connection error occurred");
        };
      }

      /**
       * Close WebSocket connection cleanly
       */
      function closeConnection() {
        if (state.ws) {
          try {
            // Clear event handlers explicitly to prevent memory leaks
            state.ws.onopen = null;
            state.ws.onmessage = null;
            state.ws.onclose = null;
            state.ws.onerror = null;
            
            state.ws.close(1000, "Client disconnect");
          } catch (error) {
            console.error("Error closing WebSocket:", error);
          }
          state.ws = null;
        }
        state.connected = false;
      }

      /**
       * Schedule reconnection attempt
       */
      function scheduleReconnect() {
        if (state.reconnectAttempts < CONFIG.MAX_RECONNECT_ATTEMPTS && state.online) {
          state.reconnectAttempts++;
          const delay = CONFIG.RECONNECT_DELAY * Math.pow(2, state.reconnectAttempts - 1);
          
          showMessage(`Reconnecting in ${delay/1000}s... (${state.reconnectAttempts}/${CONFIG.MAX_RECONNECT_ATTEMPTS})`);
          
          setTimeout(() => {
            if (!state.connected && state.online) {
              attemptConnection();
            }
          }, delay);
        } else {
          showMessage('Max reconnection attempts reached. Refresh to try again.', true);
        }
      }

      /**
       * Theme management with error handling
       */
      function setTheme(themeName = null) {
        if (!state.term) return;

        try {
          const currentTheme = themeName || localStorage.getItem(CONFIG.STORAGE_THEME_KEY) || CONFIG.DEFAULT_THEME;
          
          if (currentTheme === "light") {
            setLightTheme();
          } else {
            setDarkTheme();
          }
        } catch (error) {
          console.error("Error setting theme:", error);
          setDarkTheme(); // Fallback to dark theme
        }
      }

      /**
       * Apply dark theme
       */
      function setDarkTheme() {
        try {
          localStorage.setItem(CONFIG.STORAGE_THEME_KEY, "dark");
          if (state.term) {
            state.term.setOption('theme', { 
              background: '#000000', 
              foreground: "#ffffff", 
              cursor: "#ffffff", 
              selection: "rgba(188,214,141, 0.4)" 
            });
          }
          updateThemeButton("Light theme");
        } catch (error) {
          console.error("Error applying dark theme:", error);
        }
      }

      /**
       * Apply light theme
       */
      function setLightTheme() {
        try {
          localStorage.setItem(CONFIG.STORAGE_THEME_KEY, "light");
          if (state.term) {
            state.term.setOption('theme', { 
              background: '#ffffff', 
              foreground: "#000000", 
              cursor: "#000000", 
              selection: "rgba(188,214,141, 0.4)" 
            });
          }
          updateThemeButton("Dark theme");
        } catch (error) {
          console.error("Error applying light theme:", error);
        }
      }

      /**
       * Update theme button text
       */
      function updateThemeButton(text) {
        if (elements.toggleTheme) {
          elements.toggleTheme.value = text;
        }
      }

      /**
       * Toggle between themes
       */
      function toggleTheme() {
        try {
          const currentTheme = localStorage.getItem(CONFIG.STORAGE_THEME_KEY) || CONFIG.DEFAULT_THEME;
          
          if (currentTheme === "light") {
            setDarkTheme();
          } else {
            setLightTheme();
          }
          
          if (state.term) {
            state.term.focus();
          }
        } catch (error) {
          console.error("Error toggling theme:", error);
        }
      }

      /**
       * Start periodic memory cleanup
       */
      function startPeriodicCleanup() {
        // Clear existing interval first
        if (state.cleanupInterval) {
          clearInterval(state.cleanupInterval);
        }
        
        state.cleanupInterval = setInterval(() => {
          if (state.term && state.connected) {
            try {
              // Log memory usage for monitoring
              logMemoryUsage();
              
              // Clear excess scrollback buffer
              const buffer = state.term.buffer;
              if (buffer && buffer.lines && buffer.lines.length > CONFIG.MAX_SCROLLBACK_LINES) {
                console.log("Cleaning up terminal buffer - lines:", buffer.lines.length);
                // Clear the terminal display but keep connection
                state.term.clear();
              }
              
              // Reset current line if it's getting too long
              if (state.currentLine.length > CONFIG.MAX_CURRENT_LINE_LENGTH) {
                console.log("Resetting long current line - length:", state.currentLine.length);
                state.currentLine = "";
              }
            } catch (error) {
              console.error("Error during periodic cleanup:", error);
            }
          }
        }, CONFIG.BUFFER_CLEANUP_INTERVAL);
      }

      /**
       * Log memory usage for monitoring
       */
      function logMemoryUsage() {
        if (performance.memory) {
          const used = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
          const total = (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2);
          console.log(`Memory - Used: ${used}MB, Total: ${total}MB`);
        }
      }

      /**
       * Cleanup function for page unload
       */
      function cleanup() {
        // Stop periodic cleanup
        if (state.cleanupInterval) {
          clearInterval(state.cleanupInterval);
          state.cleanupInterval = null;
        }
        
        // Clean up terminal event handlers
        cleanupTerminalEventHandlers();
        
        // Close WebSocket connection
        closeConnection();
        
        // Dispose terminal
        if (state.term) {
          try {
            state.term.dispose();
          } catch (error) {
            console.error("Error disposing terminal:", error);
          }
          state.term = null;
        }
      }

      /**
       * Initialize the application
       */
      function initialize() {
        try {
          console.log("Initializing Altair Terminal...");
          
          if (!initializeElements()) {
            return false;
          }

          initializeNetworkHandlers();
          
          if (!initializeTerminal()) {
            return false;
          }

          attemptConnection();

          // Start periodic memory cleanup
          startPeriodicCleanup();

          // Set up cleanup on page unload
          window.addEventListener('beforeunload', cleanup);
          
          console.log("Altair Terminal initialized successfully");
          return true;
        } catch (error) {
          console.error("Failed to initialize Altair Terminal:", error);
          showError("Initialization failed: " + error.message);
          return false;
        }
      }

      // Public API
      return {
        initialize,
        toggleTheme,
        cleanup
      };
    })();

    // Global functions for HTML onclick handlers (maintained for compatibility)
    function toggleTheme() {
      AltairTerminal.toggleTheme();
    }

    // Initialize when DOM is loaded
    function initTerminal() {
      AltairTerminal.initialize();
    }
  </script>
  <title>ALTAIR 8800 Emulator</title>
</head>

<body onload="initTerminal();">

  <div style="display: flex;">
    Altair:<div id="host_name" style="display: inline;"></div>
    <div id="docs" style="margin-left: auto;">
      <a href="https://github.com/AzureSphereCloudEnabledAltair8800/RetroGames" target="_blank">Games</a>
      <a href="https://gloveboxes.github.io/altair_8800_docs/" target="_blank">Documentation</a>
      <a href="https://gloveboxes.github.io/altair_8800_docs/start/programming/Manuals" target="_blank">Manuals</a>
    </div>
  </div>

  <div style="display: flex;">
    <div style="flex-grow: 1;">
      <div id="inputmode">Line input mode: Default (Ctrl+L to toggle), Reboot Altair (Ctrl+M, R, Enter)</div>
    </div>
    <div style="display: flex; justify-content: flex-end;">
      <input id="toggleTheme" type="button" onclick="toggleTheme()" value="Light theme"></input>
    </div>
  </div>

  <div id="terminal"></div>

  <div id="version">3.2.0</div>

</body>

</html>